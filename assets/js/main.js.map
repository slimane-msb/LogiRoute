{"version":3,"file":"main.js","sources":["../../src/utils/distance.ts","../../src/utils/graph_loader.ts","../../node_modules/heap/lib/heap.js","../../node_modules/heap/index.js","../../src/algorithms/shortest path/dijkstra.ts","../../src/algorithms/shortest path/astar.ts","../../src/algorithms/shortest path/greedyBestFirstSearch.ts","../../src/algorithms/shortest path/chosen_algo.ts","../../src/algorithms/TSP/greedy_insertion.ts","../../src/algorithms/TSP/held_karp.ts","../../src/algorithms/TSP/lin_kernighan_heuristic.ts","../../src/algorithms/TSP/metaheuristics.ts","../../src/algorithms/TSP/nearest_neighbor_twoOpt.ts","../../src/algorithms/TSP/TwoOpt_Lin_Kernighan.ts","../../src/algorithms/TSP/chosen_tsp.ts"],"sourcesContent":["import { Point, Node} from \"./types\";\n\n// haversine : Helper function \nfunction getDistance(point1: Point, point2: Point): number {\n  const R = 6371e3; // Earth's radius in meters\n  const lat1 = point1.lat;\n  const lon1 = point1.lng || point1.lng;\n  const lat2 = point2.lat;\n  const lon2 = point2.lng || point2.lng;\n  \n  if (lon1 === undefined || lon2 === undefined) {\n    throw new Error('Points must have lng or lon property');\n  }\n  \n  const φ1 = lat1 * Math.PI / 180;\n  const φ2 = lat2 * Math.PI / 180;\n  const Δφ = (lat2 - lat1) * Math.PI / 180;\n  const Δλ = (lon2 - lon1) * Math.PI / 180;\n  \n  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n    Math.cos(φ1) * Math.cos(φ2) *\n    Math.sin(Δλ/2) * Math.sin(Δλ/2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n  \n  return R * c;\n}\n\n\n\n/**\n * Find nearest node to a point in the graph\n * @param point - Point with lat/lng or lon\n * @param nodes - Graph nodes object\n * @returns Nearest node\n */\nfunction findNearestNode(point: Point, nodes: Record<string, Node>): Node | null {\n  let nearest: Node | null = null;\n  let minDist = Infinity;\n\n  Object.values(nodes).forEach(node => {\n      const dist = getDistance(\n          { lat: point.lat, lng: point.lng ?? point.lng ?? 0 },\n          { lat: node.lat, lng: node.lng }\n      );\n\n      if (dist < minDist) {\n          minDist = dist;\n          nearest = node;\n      }\n  });\n\n  return nearest;\n}\n\n\nexport{\n  getDistance,\n  findNearestNode\n}","import { Edge, Graph, Node } from './types';\n\nfunction processGraphData(\n  nodesRaw: { id: number; lat: number; lng: number }[],\n  edgesRaw: { from_node_id: number; to_node_id: number; distance: number }[],\n  adjacencyRaw: Record<string, { to: number; distance: number }[]>\n): Graph {\n  const nodes: Record<string, Node> = {};\n  nodesRaw.forEach((n) => {\n    nodes[n.id.toString()] = { id: n.id.toString(), lat: n.lat, lng: n.lng };\n  });\n\n  const edges: Edge[] = edgesRaw.map((e) => ({\n    from: e.from_node_id.toString(),\n    to: e.to_node_id.toString(),\n    distance: e.distance,\n  }));\n\n  const adjacency: Record<string, Edge[]> = {};\n  for (const fromId in adjacencyRaw) {\n    adjacency[fromId] = adjacencyRaw[fromId].map((e) => ({\n      from: fromId,\n      to: e.to.toString(),\n      distance: e.distance,\n    }));\n  }\n\n  return { nodes, edges, adjacency };\n}\n\nfunction loadGraph(\n  nodesFilePath: string, \n  edgesFilePath: string, \n  adjacencyFilePath: string\n): Graph {\n  // @ts-ignore - require only exists in Node.js (for ts tests)\n  const fs = require('fs');\n  // @ts-ignore\n  const path = require('path');\n\n  const nodesRaw: { id: number; lat: number; lng: number }[] = JSON.parse(\n    fs.readFileSync(path.resolve(nodesFilePath), 'utf-8')\n  );\n  const edgesRaw: { from_node_id: number; to_node_id: number; distance: number }[] = JSON.parse(\n    fs.readFileSync(path.resolve(edgesFilePath), 'utf-8')\n  );\n  const adjacencyRaw: Record<string, { to: number; distance: number }[]> = JSON.parse(\n    fs.readFileSync(path.resolve(adjacencyFilePath), 'utf-8')\n  );\n\n  return processGraphData(nodesRaw, edgesRaw, adjacencyRaw);\n}\n\n\nfunction load_city_graph(city: string): Graph {\n  const allowedCities = ['dublin', 'paris'];\n  \n  if (!allowedCities.includes(city)) {\n    throw new Error(`City must be one of ${allowedCities.join(', ')}`);\n  }\n\n  return loadGraph(\n    `./data/${city}_nodes.json`,\n    `./data/${city}_edges.json`,\n    `./data/${city}_adjacency.json`\n  );\n}\n\n//  Async version for browser\nasync function loadGraphAsync(\n  nodesFilePath: string,\n  edgesFilePath: string,\n  adjacencyFilePath: string\n): Promise<Graph> {\n  const [nodesResponse, edgesResponse, adjacencyResponse] = await Promise.all([\n    fetch(nodesFilePath),\n    fetch(edgesFilePath),\n    fetch(adjacencyFilePath)\n  ]);\n\n  const nodesRaw = await nodesResponse.json();\n  const edgesRaw = await edgesResponse.json();\n  const adjacencyRaw = await adjacencyResponse.json();\n\n  return processGraphData(nodesRaw, edgesRaw, adjacencyRaw);\n}\n\nexport { \n  loadGraph,\n  load_city_graph,\n  loadGraphAsync  // Export async version for browser use\n};\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","module.exports = require('./lib/heap');\n","import { Edge, Graph, Node } from \"@/utils/types\";\nimport Heap from \"heap\"; \n\n\n\nfunction dijkstraHeap(\n    graph: Graph,\n    start: string,\n    end: string\n  ): { distance: number; path: string[] } {\n    const distances: Record<string, number> = {};\n    const previous: Record<string, string | null> = {};\n    const visited = new Set<string>();\n  \n    for (const nodeId in graph.nodes) {\n      distances[nodeId] = Infinity;\n      previous[nodeId] = null;\n    }\n    distances[start] = 0;\n  \n    const heap = new Heap<{ id: string; dist: number }>((a, b) => a.dist - b.dist);\n    heap.push({ id: start, dist: 0 });\n  \n    while (!heap.empty()) {\n      const { id: currentNode, dist } = heap.pop()!;\n      if (visited.has(currentNode)) continue;\n      visited.add(currentNode);\n  \n      if (currentNode === end) break;\n  \n      for (const edge of graph.adjacency[currentNode] || []) {\n        const neighbor = edge.to;\n        const newDist = distances[currentNode] + edge.distance;\n        if (newDist < distances[neighbor]) {\n          distances[neighbor] = newDist;\n          previous[neighbor] = currentNode;\n          heap.push({ id: neighbor, dist: newDist });\n        }\n      }\n    }\n  \n    const path: string[] = [];\n    let node: string | null = end;\n    if (distances[end] === Infinity) return { distance: Infinity, path: [] };\n    while (node) {\n      path.unshift(node);\n      node = previous[node];\n    }\n  \n    return { distance: distances[end], path };\n  }\n  \n\n\n  function dijkstra(\n    graph: Graph,\n    start: string,\n    end: string\n  ): { distance: number; path: string[] } {\n  \n    const distances: Record<string, number> = {};\n    const previous: Record<string, string | null> = {};\n    const visited = new Set<string>();\n  \n    \n    for (const nodeId in graph.nodes) {\n      distances[nodeId] = Infinity;\n      previous[nodeId] = null;\n    }\n    \n    distances[start] = 0;\n  \n    while (visited.size < Object.keys(graph.nodes).length) {\n      \n      let currentNode: string | null = null;\n      let minDist = Infinity;\n      for (const nodeId in distances) {\n        if (!visited.has(nodeId) && distances[nodeId] < minDist) {\n          minDist = distances[nodeId];\n          currentNode = nodeId;\n        }\n      }\n  \n      if (!currentNode) break; \n      if (currentNode === end) break; \n  \n      visited.add(currentNode);\n  \n      \n      for (const edge of graph.adjacency[currentNode] || []) {\n        const neighbor = edge.to;\n        const newDist = distances[currentNode] + edge.distance;\n        if (newDist < distances[neighbor]) {\n          distances[neighbor] = newDist;\n          previous[neighbor] = currentNode;\n        }\n      }\n            \n    }\n  \n    \n    const path: string[] = [];\n    let node: string | null = end;\n    if (distances[end] === Infinity) {\n      return { distance: Infinity, path: [] }; \n    }\n    while (node) {\n      path.unshift(node);\n      node = previous[node];\n    }\n  \n    return { distance: distances[end], path };\n}\n\n\n  \n\nexport{\n    dijkstra,\n    dijkstraHeap\n}","import Heap from \"heap\";\nimport { Graph } from \"../../utils/types\";\nimport { getDistance } from \"../../utils/distance\";\n\nfunction astar(\n  graph: Graph,\n  start: string,\n  end: string\n): { distance: number; path: string[] } {\n\n  const gScore: Record<string, number> = {};\n  const fScore: Record<string, number> = {};\n  const previous: Record<string, string | null> = {};\n  const visited = new Set<string>();\n\n  for (const nodeId in graph.nodes) {\n    gScore[nodeId] = Infinity;\n    fScore[nodeId] = Infinity;\n    previous[nodeId] = null;\n  }\n\n  gScore[start] = 0;\n\n  const endNode = graph.nodes[end];\n  const startNode = graph.nodes[start];\n\n  fScore[start] = getDistance(\n    startNode,\n    endNode,\n  );\n\n  const openSet = new Heap<{ id: string; f: number }>(\n    (a, b) => a.f - b.f\n  );\n\n  openSet.push({ id: start, f: fScore[start] });\n\n  while (!openSet.empty()) {\n    const { id: current } = openSet.pop()!;\n    if (visited.has(current)) continue;\n\n    if (current === end) break;\n    visited.add(current);\n\n    for (const edge of graph.adjacency[current] || []) {\n      const neighbor = edge.to;\n      const tentativeG = gScore[current] + edge.distance;\n\n      if (tentativeG < gScore[neighbor]) {\n        gScore[neighbor] = tentativeG;\n        previous[neighbor] = current;\n\n        const neighborNode = graph.nodes[neighbor];\n        fScore[neighbor] =\n          tentativeG +\n          getDistance(\n            neighborNode,\n            endNode,\n          );\n\n        openSet.push({ id: neighbor, f: fScore[neighbor] });\n      }\n    }\n  }\n\n  // Reconstruct path\n  if (gScore[end] === Infinity) {\n    return { distance: Infinity, path: [] };\n  }\n\n  const path: string[] = [];\n  let node: string | null = end;\n  while (node) {\n    path.unshift(node);\n    node = previous[node];\n  }\n\n  return { distance: gScore[end], path };\n}\n\n\nexport{\n  astar\n}","import Heap from \"heap\";\nimport { Graph, Node} from \"@/utils/types\";\nimport { getDistance } from \"../../utils/distance\";\n\nfunction greedyBestFirstSearch(\n  graph: Graph,\n  start: string,\n  end: string\n): { distance: number; path: string[] } {\n\n  const visited = new Set<string>();\n  const previous: Record<string, string | null> = {};\n  const distance: Record<string, number> = {};\n\n  for (const nodeId in graph.nodes) {\n    previous[nodeId] = null;\n    distance[nodeId] = Infinity;\n  }\n\n  distance[start] = 0;\n\n  const endNode = graph.nodes[end];\n\n  const openSet = new Heap<{ id: string; h: number }>(\n    (a, b) => a.h - b.h\n  );\n\n  const startNode = graph.nodes[start];\n  openSet.push({\n    id: start,\n    h: getDistance(\n      startNode,\n      endNode\n    ),\n  });\n\n  while (!openSet.empty()) {\n    const { id: current } = openSet.pop()!;\n    if (visited.has(current)) continue;\n    visited.add(current);\n\n    if (current === end) break;\n\n    for (const edge of graph.adjacency[current] || []) {\n      const neighbor = edge.to;\n      if (visited.has(neighbor)) continue;\n\n      // record path and cumulative distance (not used for priority)\n      const newDist = distance[current] + edge.distance;\n      if (newDist < distance[neighbor]) {\n        distance[neighbor] = newDist;\n        previous[neighbor] = current;\n\n        const neighborNode = graph.nodes[neighbor];\n        openSet.push({\n          id: neighbor,\n          h: getDistance(\n            neighborNode,\n            endNode\n          ),\n        });\n      }\n    }\n  }\n\n  if (distance[end] === Infinity) {\n    return { distance: Infinity, path: [] };\n  }\n\n  const path: string[] = [];\n  let node: string | null = end;\n  while (node) {\n    path.unshift(node);\n    node = previous[node];\n  }\n\n  return { distance: distance[end], path };\n}\n\nexport{\n    greedyBestFirstSearch\n}","\nimport { Graph } from \"../../utils/types\";\nimport { astar } from \"./astar\";\n\n// both astar and greedyBestFirstSearch are fast, astar is better in shortestPath\nfunction shortestPath(\n  graph: Graph,\n  start: string,\n  end: string\n): { distance: number; path: string[] }{\n    return (astar(graph, start, end))\n}\n\n\nexport{\n    shortestPath\n}","import { Graph, TSPResult} from \"../../utils/types\";\n\n\n/**\n * Compute total distance of a tour given order indices and distance matrix\n */\nfunction tourDistance(order: number[], dist: number[][]): number {\n  let total = 0;\n  for (let i = 0; i < order.length - 1; i++) {\n    total += dist[order[i]][order[i + 1]];\n  }\n  return total;\n}\n\n/**\n * Greedy Insertion / Cheapest Insertion TSP\n */\nfunction greedyInsertionTSP(\n  graph: Graph,\n  targets: string[],\n  shortestPathFunc: (graph: Graph, from: string, to: string) => { distance: number; path: string[] }\n): TSPResult {\n  const n = targets.length;\n\n  // 1. Distance matrix and path segments\n  const dist: number[][] = Array.from({ length: n }, () => Array(n).fill(Infinity));\n  const paths: string[][][] = Array.from({ length: n }, () => Array.from({ length: n }, () => []));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i === j) continue;\n      const res = shortestPathFunc(graph, targets[i], targets[j]);\n      dist[i][j] = res.distance;\n      paths[i][j] = res.path;\n    }\n  }\n\n  // 2. Initialize tour with first two nodes\n  const order: number[] = [0, 1];\n\n  const unvisited = new Set<number>();\n  for (let i = 2; i < n; i++) unvisited.add(i);\n\n  // 3. Insert remaining nodes greedily\n  while (unvisited.size > 0) {\n    let bestIncrease = Infinity;\n    let bestNode = -1;\n    let bestPosition = -1;\n\n    for (const node of unvisited) {\n      for (let pos = 0; pos < order.length; pos++) {\n        const nextPos = (pos + 1) % order.length;\n        const increase = dist[order[pos]][node] + dist[node][order[nextPos]] - dist[order[pos]][order[nextPos]];\n        if (increase < bestIncrease) {\n          bestIncrease = increase;\n          bestNode = node;\n          bestPosition = nextPos;\n        }\n      }\n    }\n\n    order.splice(bestPosition, 0, bestNode);\n    unvisited.delete(bestNode);\n  }\n\n  // 4. Build full road-level path\n  const fullPath: string[] = [];\n  for (let i = 0; i < order.length - 1; i++) {\n    const a = order[i];\n    const b = order[i + 1];\n    const segment = paths[a][b];\n    if (i === 0) {\n      fullPath.push(...segment);\n    } else {\n      fullPath.push(...segment.slice(1));\n    }\n  }\n\n  const resultOrder = order.map(i => targets[i]);\n  const distance = tourDistance(order, dist);\n\n  return { order: resultOrder, path: fullPath, distance };\n}\n\n\nexport{\n  greedyInsertionTSP\n}","import { Graph, TSPResult, Node } from \"../../utils/types\";\nimport { shortestPath } from \"../shortest path/chosen_algo\";\n\n\n function heldKarpTSP(\n    graph: Graph,\n    targets: string[],\n    shortestPath: (\n      graph: Graph,\n      from: string,\n      to: string\n    ) => { distance: number; path: string[] }\n  ): TSPResult {\n    const n = targets.length;\n  \n    /* -------------------------------------------\n     * 1. Metric closure (shortestPath (A* / Dijkstra...) between targets)\n     * ------------------------------------------- */\n  \n    const dist: number[][] = Array.from({ length: n }, () =>\n      Array(n).fill(Infinity)\n    );\n  \n    const paths: string[][][] = Array.from({ length: n }, () =>\n      Array.from({ length: n }, () => [])\n    );\n  \n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        if (i === j) continue;\n        const res = shortestPath(graph, targets[i], targets[j]);\n        dist[i][j] = res.distance;\n        paths[i][j] = res.path;\n      }\n    }\n  \n    /* -------------------------------------------\n     * 2. Held–Karp DP (What is the shortest path that visits every target exactly once)\n     * ------------------------------------------- */\n  \n    const size = 1 << n;\n    const dp: number[][] = Array.from({ length: size }, () =>\n      Array(n).fill(Infinity)\n    );\n    const parent: number[][] = Array.from({ length: size }, () =>\n      Array(n).fill(-1)\n    );\n  \n    // Init\n    for (let i = 0; i < n; i++) {\n      dp[1 << i][i] = 0;\n    }\n  \n    // Transitions\n    for (let mask = 1; mask < size; mask++) {\n      for (let i = 0; i < n; i++) {\n        if (!(mask & (1 << i))) continue;\n  \n        const prevMask = mask ^ (1 << i);\n        if (prevMask === 0) continue;\n  \n        for (let j = 0; j < n; j++) {\n          if (!(prevMask & (1 << j))) continue;\n  \n          const candidate = dp[prevMask][j] + dist[j][i];\n          if (candidate < dp[mask][i]) {\n            dp[mask][i] = candidate;\n            parent[mask][i] = j;\n          }\n        }\n      }\n    }\n  \n    /* -------------------------------------------\n     * 3. Find best endpoint\n     * ------------------------------------------- */\n  \n    const fullMask = size - 1;\n    let bestCost = Infinity;\n    let last = -1;\n  \n    for (let i = 0; i < n; i++) {\n      if (dp[fullMask][i] < bestCost) {\n        bestCost = dp[fullMask][i];\n        last = i;\n      }\n    }\n  \n    /* -------------------------------------------\n     * 4. Reconstruct visit order\n     * ------------------------------------------- */\n  \n    const orderIdx: number[] = [];\n    let mask = fullMask;\n    let curr = last;\n  \n    while (curr !== -1) {\n      orderIdx.push(curr);\n      const p = parent[mask][curr];\n      mask ^= 1 << curr;\n      curr = p;\n    }\n  \n    orderIdx.reverse();\n    const order = orderIdx.map(i => targets[i]);\n  \n    /* -------------------------------------------\n     * 5. Build full road-level path\n     * ------------------------------------------- */\n  \n    const fullPath: string[] = [];\n    for (let i = 0; i < orderIdx.length - 1; i++) {\n      const a = orderIdx[i];\n      const b = orderIdx[i + 1];\n      const segment = paths[a][b];\n  \n      if (i === 0) {\n        fullPath.push(...segment);\n      } else {\n        // avoid duplicate node\n        fullPath.push(...segment.slice(1));\n      }\n    }\n  \n    return {\n      order,\n      path: fullPath,\n      distance: bestCost\n    };\n}\n  \n\nexport{\n  heldKarpTSP\n}","import { Graph, TSPResult, Node } from \"@/utils/types\";\n\n\n/**\n * Swap 2-opt segment\n */\nfunction twoOptSwap(order: number[], i: number, k: number): number[] {\n  return order.slice(0, i).concat(order.slice(i, k + 1).reverse(), order.slice(k + 1));\n}\n\n/**\n * Compute tour distance\n */\nfunction tourDistance(order: number[], dist: number[][]): number {\n  let total = 0;\n  for (let i = 0; i < order.length - 1; i++) {\n    total += dist[order[i]][order[i + 1]];\n  }\n  return total;\n}\n\n/**\n * Lin-Kernighan heuristic simplified for TypeScript\n */\nfunction linKernighanTSP(\n  graph: Graph,\n  targets: string[],\n  shortestPathFunc: (graph: Graph, from: string, to: string) => { distance: number; path: string[] }\n): TSPResult {\n  const n = targets.length;\n\n  // 1. Build distance matrix and path segments\n  const dist: number[][] = Array.from({ length: n }, () => Array(n).fill(Infinity));\n  const paths: string[][][] = Array.from({ length: n }, () => Array.from({ length: n }, () => []));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i === j) continue;\n      const res = shortestPathFunc(graph, targets[i], targets[j]);\n      dist[i][j] = res.distance;\n      paths[i][j] = res.path;\n    }\n  }\n\n  // 2. Initial tour: Nearest Neighbor\n  const order: number[] = [];\n  const visited = new Set<number>();\n  let current = 0;\n  order.push(current);\n  visited.add(current);\n\n  while (order.length < n) {\n    let nearest = -1;\n    let nearestDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (!visited.has(i) && dist[current][i] < nearestDist) {\n        nearest = i;\n        nearestDist = dist[current][i];\n      }\n    }\n    current = nearest;\n    order.push(current);\n    visited.add(current);\n  }\n\n  // 3. Lin-Kernighan improvement loop (2-opt + 3-opt)\n  let improved = true;\n  while (improved) {\n    improved = false;\n\n    // 2-opt\n    for (let i = 1; i < n - 1; i++) {\n      for (let k = i + 1; k < n; k++) {\n        const newOrder = twoOptSwap(order, i, k);\n        if (tourDistance(newOrder, dist) < tourDistance(order, dist)) {\n          order.splice(0, order.length, ...newOrder);\n          improved = true;\n        }\n      }\n    }\n\n    // 3-opt: attempt removing 3 edges and reconnecting in better way\n    for (let i = 0; i < n - 2; i++) {\n      for (let j = i + 1; j < n - 1; j++) {\n        for (let k = j + 1; k < n; k++) {\n          // 3 possible reconnections (simplified)\n          const newOrders = [\n            [...order.slice(0, i), ...order.slice(i, j + 1).reverse(), ...order.slice(j + 1, k + 1), ...order.slice(k + 1)],\n            [...order.slice(0, i), ...order.slice(i, j + 1), ...order.slice(j + 1, k + 1).reverse(), ...order.slice(k + 1)],\n            [...order.slice(0, i), ...order.slice(i, j + 1).reverse(), ...order.slice(j + 1, k + 1).reverse(), ...order.slice(k + 1)]\n          ];\n\n          for (const newOrder of newOrders) {\n            if (tourDistance(newOrder, dist) < tourDistance(order, dist)) {\n              order.splice(0, order.length, ...newOrder);\n              improved = true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 4. Build full road path\n  const fullPath: string[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = order[i];\n    const b = order[i + 1];\n    const segment = paths[a][b];\n    if (i === 0) {\n      fullPath.push(...segment);\n    } else {\n      fullPath.push(...segment.slice(1));\n    }\n  }\n\n  const resultOrder = order.map(i => targets[i]);\n  const distance = tourDistance(order, dist);\n\n  return { order: resultOrder, path: fullPath, distance };\n}\n\n\nexport{\n  linKernighanTSP\n}","import { Graph, TSPResult, Node } from \"@/utils/types\";\n\n\n\nfunction tourDistance(order: number[], dist: number[][]): number {\n  let total = 0;\n  for (let i = 0; i < order.length - 1; i++) {\n    total += dist[order[i]][order[i + 1]];\n  }\n  return total;\n}\n\n// Shuffle array (Fisher-Yates)\nfunction shuffle<T>(arr: T[]): T[] {\n  const a = arr.slice();\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n\n/**\n * Genetic Algorithm for TSP\n */\nfunction metaheuristics(\n  graph: Graph,\n  targets: string[],\n  shortestPathFunc: (graph: Graph, from: string, to: string) => { distance: number; path: string[] },\n  populationSize = 50,\n  generations = 200,\n  mutationRate = 0.1\n): TSPResult {\n  const n = targets.length;\n\n  // 1. Build distance matrix\n  const dist: number[][] = Array.from({ length: n }, () => Array(n).fill(Infinity));\n  const paths: string[][][] = Array.from({ length: n }, () => Array.from({ length: n }, () => []));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i === j) continue;\n      const res = shortestPathFunc(graph, targets[i], targets[j]);\n      dist[i][j] = res.distance;\n      paths[i][j] = res.path;\n    }\n  }\n\n  // 2. Initial population\n  let population: number[][] = [];\n  for (let i = 0; i < populationSize; i++) {\n    population.push(shuffle([...Array(n).keys()]));\n  }\n\n  // 3. Evolution loop\n  for (let gen = 0; gen < generations; gen++) {\n    // Evaluate fitness\n    const fitness = population.map(order => 1 / tourDistance(order, dist));\n\n    // Selection (roulette wheel)\n    const newPopulation: number[][] = [];\n    while (newPopulation.length < populationSize) {\n      const select = () => {\n        const r = Math.random() * fitness.reduce((a, b) => a + b, 0);\n        let sum = 0;\n        for (let i = 0; i < fitness.length; i++) {\n          sum += fitness[i];\n          if (sum >= r) return population[i].slice();\n        }\n        return population[fitness.length - 1].slice();\n      };\n\n      let parent1 = select();\n      let parent2 = select();\n\n      // Crossover (order crossover)\n      const start = Math.floor(Math.random() * n);\n      const end = start + Math.floor(Math.random() * (n - start));\n      const child = Array(n).fill(-1);\n      for (let i = start; i < end; i++) child[i] = parent1[i];\n\n      let fillIdx = 0;\n      for (let gene of parent2) {\n        if (!child.includes(gene)) {\n          while (child[fillIdx] !== -1) fillIdx++;\n          child[fillIdx] = gene;\n        }\n      }\n\n      // Mutation (swap)\n      if (Math.random() < mutationRate) {\n        const a = Math.floor(Math.random() * n);\n        const b = Math.floor(Math.random() * n);\n        [child[a], child[b]] = [child[b], child[a]];\n      }\n\n      newPopulation.push(child);\n    }\n\n    population = newPopulation;\n  }\n\n  // 4. Pick best individual\n  let best = population[0];\n  let bestDist = tourDistance(best, dist);\n  for (const order of population) {\n    const d = tourDistance(order, dist);\n    if (d < bestDist) {\n      best = order;\n      bestDist = d;\n    }\n  }\n\n  // 5. Build full road path\n  const fullPath: string[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = best[i];\n    const b = best[i + 1];\n    const segment = paths[a][b];\n    if (i === 0) {\n      fullPath.push(...segment);\n    } else {\n      fullPath.push(...segment.slice(1));\n    }\n  }\n\n  const resultOrder = best.map(i => targets[i]);\n  const distance = bestDist;\n\n  return { order: resultOrder, path: fullPath, distance };\n}\n\n\nexport{\n  metaheuristics\n}","import { Graph, TSPResult } from \"../../utils/types\";\n\n\n\n/**\n * 2-opt swap: reverse segment between i and k\n */\nfunction twoOptSwap(order: number[], i: number, k: number): number[] {\n  const newOrder = order.slice(0, i);\n  const reversed = order.slice(i, k + 1).reverse();\n  return newOrder.concat(reversed).concat(order.slice(k + 1));\n}\n\n/**\n * Compute total distance of a tour given order indices and distance matrix\n */\nfunction tourDistance(order: number[], dist: number[][]): number {\n  let total = 0;\n  for (let i = 0; i < order.length - 1; i++) {\n    total += dist[order[i]][order[i + 1]];\n  }\n  return total;\n}\n\n/**\n * Nearest Neighbor + 2-opt TSP\n */\nfunction nearestNeighbor2OptTSP(\n  graph: Graph,\n  targets: string[],\n  shortestPathFunc: (graph: Graph, from: string, to: string) => { distance: number; path: string[] }\n): TSPResult {\n  const n = targets.length;\n\n  // 1. Compute distance matrix and path segments\n  const dist: number[][] = Array.from({ length: n }, () => Array(n).fill(Infinity));\n  const paths: string[][][] = Array.from({ length: n }, () => Array.from({ length: n }, () => []));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i === j) continue;\n      const res = shortestPathFunc(graph, targets[i], targets[j]);\n      dist[i][j] = res.distance;\n      paths[i][j] = res.path;\n    }\n  }\n\n  // 2. Initial tour using Nearest Neighbor\n  const order: number[] = [];\n  const visited = new Set<number>();\n  let current = 0;\n  order.push(current);\n  visited.add(current);\n\n  while (order.length < n) {\n    let nearest = -1;\n    let nearestDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (!visited.has(i) && dist[current][i] < nearestDist) {\n        nearest = i;\n        nearestDist = dist[current][i];\n      }\n    }\n    current = nearest;\n    order.push(current);\n    visited.add(current);\n  }\n\n  // 3. Apply 2-opt improvement\n  let improved = true;\n  while (improved) {\n    improved = false;\n    for (let i = 1; i < n - 1; i++) {\n      for (let k = i + 1; k < n; k++) {\n        const newOrder = twoOptSwap(order, i, k);\n        if (tourDistance(newOrder, dist) < tourDistance(order, dist)) {\n          order.splice(0, order.length, ...newOrder);\n          improved = true;\n        }\n      }\n    }\n  }\n\n  // 4. Build full road-level path\n  const fullPath: string[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = order[i];\n    const b = order[i + 1];\n    const segment = paths[a][b];\n    if (i === 0) {\n      fullPath.push(...segment);\n    } else {\n      fullPath.push(...segment.slice(1)); // avoid duplicates\n    }\n  }\n\n  const resultOrder = order.map(i => targets[i]);\n  const distance = tourDistance(order, dist);\n\n  return { order: resultOrder, path: fullPath, distance };\n}\n\n\nexport{\n  nearestNeighbor2OptTSP\n}","\nimport { Graph, Node, TSPResult } from \"../../utils/types\";\nimport { shortestPath } from \"../shortest path/chosen_algo\"; \n\n/**\n * 2-opt swap: reverse segment between i and k\n */\nfunction twoOptSwap(order: number[], i: number, k: number): number[] {\n  const newOrder = order.slice(0, i);\n  const reversed = order.slice(i, k + 1).reverse();\n  return newOrder.concat(reversed).concat(order.slice(k + 1));\n}\n\n/**\n * Compute total distance of a tour given order indices and distance matrix\n */\nfunction tourDistance(order: number[], dist: number[][]): number {\n  let total = 0;\n  for (let i = 0; i < order.length - 1; i++) {\n    total += dist[order[i]][order[i + 1]];\n  }\n  return total;\n}\n\n/**\n * 2-opt local search / Lin–Kernighan style TSP\n */\n function twoOptTSP(\n  graph: Graph,\n  targets: string[],\n  shortestPathFunc: (graph: Graph, from: string, to: string) => { distance: number; path: string[] }\n): TSPResult {\n  const n = targets.length;\n\n  // 1. Compute distance matrix and path segments between targets\n  const dist: number[][] = Array.from({ length: n }, () => Array(n).fill(Infinity));\n  const paths: string[][][] = Array.from({ length: n }, () => Array.from({ length: n }, () => []));\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i === j) continue;\n      const res = shortestPathFunc(graph, targets[i], targets[j]);\n      dist[i][j] = res.distance;\n      paths[i][j] = res.path;\n    }\n  }\n\n  // 2. Initial tour (nearest neighbor)\n  const order: number[] = [];\n  const visited = new Set<number>();\n  let current = 0;\n  order.push(current);\n  visited.add(current);\n\n  while (order.length < n) {\n    let nearest = -1;\n    let nearestDist = Infinity;\n    for (let i = 0; i < n; i++) {\n      if (!visited.has(i) && dist[current][i] < nearestDist) {\n        nearest = i;\n        nearestDist = dist[current][i];\n      }\n    }\n    current = nearest;\n    order.push(current);\n    visited.add(current);\n  }\n\n  // 3. 2-opt local search\n  let improved = true;\n  while (improved) {\n    improved = false;\n    for (let i = 1; i < n - 1; i++) {\n      for (let k = i + 1; k < n; k++) {\n        const newOrder = twoOptSwap(order, i, k);\n        if (tourDistance(newOrder, dist) < tourDistance(order, dist)) {\n          order.splice(0, order.length, ...newOrder);\n          improved = true;\n        }\n      }\n    }\n  }\n\n  // 4. Build full road path\n  const fullPath: string[] = [];\n  for (let i = 0; i < n - 1; i++) {\n    const a = order[i];\n    const b = order[i + 1];\n    const segment = paths[a][b];\n    if (i === 0) {\n      fullPath.push(...segment);\n    } else {\n      fullPath.push(...segment.slice(1)); // avoid duplicates\n    }\n  }\n\n  const resultOrder = order.map(i => targets[i]);\n  const distance = tourDistance(order, dist);\n\n  return { order: resultOrder, path: fullPath, distance };\n}\n\n\nexport{\n  twoOptTSP\n}","import { Graph, TSPResult } from \"../../utils/types\";\nimport { linKernighanTSP } from \"./lin_kernighan_heuristic\";\nimport { heldKarpTSP } from \"./held_karp\";\nimport {astar } from \"../shortest path/astar\"\n\n// Wrapper to choose TSP algorithm based on number of targets\n function bestTSP(graph: Graph, targets: string[]): TSPResult {\n    if (targets.length < 15) {\n        // Use Held-Karp for small graphs (optimal path)\n        return heldKarpTSP(graph, targets, astar);\n    } else {\n        // Use Lin-Kernighan heuristic for larger graphs (fast, almost optimal path)\n        return linKernighanTSP(graph, targets, astar);\n    }\n}\n\nexport{\n    bestTSP\n}"],"names":["Heap","heap","this","require$$0","tourDistance","shortestPath","mask","twoOptSwap"],"mappings":"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","x_google_ignoreList":[2,3]}